            elseif ($localPath -eq 'list-alerts' -and $request.HttpMethod -eq 'GET') {
                try {
                    [System.Threading.Monitor]::Enter($fileLock)
                    $alerts = @(Get-ChildItem -Path $alertsDirPath -Filter *.json | ForEach-Object {
                        $alert = Get-Content $_.FullName -Raw | ConvertFrom-Json
                        
                        $alert.content = Decrypt-String -EncryptedBase64 $alert.content -Key $encryptionKey
                        $alert.category = Decrypt-String -EncryptedBase64 $alert.category -Key $encryptionKey
                        $alert.difficulty = Decrypt-String -EncryptedBase64 $alert.difficulty -Key $encryptionKey
                        
                        # FIX: Safely decrypt withdrawalReason, which may not exist on old objects
                        if ($alert.PSObject.Properties['withdrawalReason']) {
                            $alert.withdrawalReason = Decrypt-String -EncryptedBase64 $alert.withdrawalReason -Key $encryptionKey
                        }
                        
                        return $alert
                    })
                    Send-JsonResponse $response $alerts
                } catch { 
                    Send-ErrorResponse $response 500 "Failed to read alerts: $($_.Exception.Message)" 
                } finally { 
                    if ([System.Threading.Monitor]::IsEntered($fileLock)) { [System.Threading.Monitor]::Exit($fileLock) } 
                }
                continue
            }
			# --- Save/Update Alert ---
			elseif ($localPath -eq 'save-alert' -and $request.HttpMethod -eq 'POST') {
				try {
					$data = (New-Object System.IO.StreamReader($request.InputStream)).ReadToEnd() | ConvertFrom-Json
					
					$entryToSave = $null
					$alertFilePath = ""
					$logMessage = ""

					if ($data.id) {
						# --- UPDATE LOGIC ---
						$alertFilePath = Join-Path $alertsDirPath "$($data.id).json"
						if (-not (Test-Path $alertFilePath)) {
							Send-ErrorResponse $response 404 "Alert with ID $($data.id) not found for update."
							continue
						}
						$existingAlert = Get-Content $alertFilePath -Raw | ConvertFrom-Json
						
						# Create the object to save with all fields encrypted
						$entryToSave = [PSCustomObject]@{
							id               = $data.id
							content          = Encrypt-String -PlainText $data.content -Key $encryptionKey
							category         = Encrypt-String -PlainText $data.category -Key $encryptionKey
							difficulty       = Encrypt-String -PlainText $data.difficulty -Key $encryptionKey
							user             = $existingAlert.user # Preserve original creator
							date             = $existingAlert.date # Preserve original date
							createdAt        = $existingAlert.createdAt # Preserve original creation timestamp
							updatedAt        = (Get-Date -Format "o") # Set new update timestamp
							isWithdrawn      = [bool]$data.isWithdrawn
						}
                        # Safely add/update the withdrawalReason property by encrypting the incoming value
                        $encryptedReason = Encrypt-String -PlainText $data.withdrawalReason -Key $encryptionKey
                        Add-Member -InputObject $entryToSave -MemberType NoteProperty -Name 'withdrawalReason' -Value $encryptedReason -Force

						$editor = if ([string]::IsNullOrWhiteSpace($data.editor)) { "Unknown user" } else { $data.editor }

						switch ($data.actionType) {
							'withdraw'    { $logMessage = "$($editor) withdrew alert $($data.id)" }
							'reintroduce' { $logMessage = "$($editor) reintroduced alert $($data.id)" }
							default       { $logMessage = "$($editor) edited alert $($data.id)" }
						}

					} else {
						# --- CREATE NEW LOGIC ---
						$newId = Get-ShortId
						
						# Create the new object with fields encrypted
						$entryToSave = [PSCustomObject]@{
							id               = $newId
							content          = Encrypt-String -PlainText $data.content -Key $encryptionKey
							category         = Encrypt-String -PlainText $data.category -Key $encryptionKey
							difficulty       = Encrypt-String -PlainText $data.difficulty -Key $encryptionKey
							user             = $data.user
							date             = (Get-Date).ToString("dd.MM.yyyy")
							createdAt        = (Get-Date -Format "o")
							updatedAt        = (Get-Date -Format "o")
							isWithdrawn      = $false
							withdrawalReason = Encrypt-String -PlainText "" -Key $encryptionKey # Encrypt an empty string for the new field
						}
						$alertFilePath = Join-Path $alertsDirPath "$newId.json"
						$logMessage = "$($entryToSave.user) added alert $($entryToSave.id)"
					}

					# Save the encrypted object to its file
					$entryToSave | ConvertTo-Json -Depth 5 | Set-Content -Path $alertFilePath -Encoding UTF8 -NoNewLine
					
                    # Write to logs
                    Write-LogEntry -Message $logMessage
					Write-AuditEntry -Message $logMessage
					
                    # Decrypt the object again before sending it back to the client.
                    # This ensures the frontend receives plaintext to update its state immediately.
                    $decryptedResponse = $entryToSave.psobject.Copy()
                    $decryptedResponse.content = Decrypt-String -EncryptedBase64 $decryptedResponse.content -Key $encryptionKey
                    $decryptedResponse.category = Decrypt-String -EncryptedBase64 $decryptedResponse.category -Key $encryptionKey
                    $decryptedResponse.difficulty = Decrypt-String -EncryptedBase64 $decryptedResponse.difficulty -Key $encryptionKey
                    $decryptedResponse.withdrawalReason = Decrypt-String -EncryptedBase64 $decryptedResponse.withdrawalReason -Key $encryptionKey

                    Send-JsonResponse $response $decryptedResponse

				} catch { 
                    Send-ErrorResponse $response 500 "Failed to save alert: $($_.Exception.Message)" 
                }
				continue
			}
